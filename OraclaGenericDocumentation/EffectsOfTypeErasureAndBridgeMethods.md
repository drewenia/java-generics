# Effects of Type Erasure and Bridge Methods

Bazen type erasure, beklemediğiniz bir duruma yol açar. Aşağıdaki örnek bunun nasıl olabileceğini gösterir. Aşağıdaki
örnek, compiler'ın bazen type erasure sürecinin bir parçası olarak synthetic bir method, yani bridge method
oluşturduğunu gösterir.

Aşağıdaki iki class verildiğinde:

```java
class Node<T> {
    public T data;

    public Node(T data) {
        this.data = data;
    }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

class MyNode extends Node<Integer> {
    public MyNode(Integer data) {
        super(data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

Aşağıdaki kodu düşünün:

```java
public static void main(String[] args) {
    MyNode mn = new MyNode(5);
    Node n = mn; // Raw type — compiler unchecked uyarısı verir.
    n.setData("Hello"); // ClassCastException atılmasına neden olur.
    Integer x = mn.data;
}
```

Type erasure'dan sonra, bu kod şu hale gelir:

```
MyNode mn = new MyNode(5);
Node n = mn;        // Raw type — compiler unchecked uyarısı verir.
                    // Bu ifade şu şekilde de olabilir: Node n = (Node)mn;
                    // Ancak, compiler cast oluşturmaz çünkü gerekli değildir.
n.setData("Hello"); // ClassCastException atılmasına neden olur.
Integer x = (Integer)mn.data;
```

Sonraki bölüm, `n.setData("Hello")`; statement'ında neden `ClassCastException` atıldığını açıklar.

## Bridge Methods

Parameterized class'ı extend eden veya parameterized interface'i implement eden bir class veya interface compile
edilirken, compiler type erasure sürecinin bir parçası olarak bridge method adı verilen synthetic bir method
oluşturabilir. Genellikle bridge method'larla uğraşmanız gerekmez, ancak bir stack trace'de görünürse şaşırabilirsiniz.

Type erasure'dan sonra, Node ve MyNode class'ları şu hale gelir:

```java
public class Node {

    public Object data;

    public Node(Object data) {
        this.data = data;
    }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) {
        super(data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

Type erasure'dan sonra, method imzaları eşleşmez; `Node.setData(T)` method'u `Node.setData(Object)` olur. Bunun sonucu
olarak, `MyNode.setData(Integer)` method'u `Node.setData(Object)` method'unu override etmez.

Bu problemi çözmek ve type erasure sonrası generic type'ların polymorphism'ini korumak için, Java compiler subtyping'in
beklenildiği gibi çalışmasını sağlamak amacıyla bir bridge method üretir.

MyNode class'ı için, compiler `setData` method'u için aşağıdaki bridge method'u oluşturur:

```java
class MyNode extends Node {

    // Bridge method generated by the compiler
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
    // ...
}
```

Bridge method `MyNode.setData(Object)`, orijinal `MyNode.setData(Integer)` method'una delegate eder. Bunun sonucu
olarak, `n.setData("Hello")`; statement'i `MyNode.setData(Object)` method'unu call eder ve `Hello` Integer'a cast
edilemediği için `ClassCastException` atılır.